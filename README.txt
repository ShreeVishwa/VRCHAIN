- A cryptocurrency is a digital medium of exchange. it has three main features - a secure blockchain,wallets and mining
- A cryptocurrency leverages the blockchain, so that it can maintain a public database of transactions
- If everyone has the access to the database then one can transfer more money to himself. So to prevent problem cryptocurrency leverage the cryptic algorithms which generate the digital signatures of different members.

- Everyone who wants to make a transaction in the blockchain has to stamp a unique digital signature. Each
  digital signature has two keys, the public key and the private key. The private key is accessible to only
  one individual and the public key is seen by everyone tp identify the individual. The digital signature
  is nothing but a hash value which is generated by the combination of the private key of the individual and
  the data. The public key is used to decrypt the signatures and read the data behind it. IF we couldn't read it
  then it means that either the data is tampered or the private key is incorrect. This adds a layer of protection
  and integrity.

- Wallets are the objects that store the public and the private key of the individual and also see how much cryptocurrency
  you are entitled to. The public key is the address of the wallet which is used by others to send the money to the wallets
  with the help of the private key the wallets are used to generate the signatures

- Mining - is nothing but adding blocks to the blockchain. When people submit the transactions to the blockchain, it takes
  some time for them to get confirmed. When transactions are sent to the network and are not included in the blockchain, then
  they are called "unconfirmed" transactions. Miners take a group of there unconfirmed transactions and include them within a
  block in the chain. The actual task of mining is to perform the computational puzzle called the "proof of work" algorithm
  This proof of work algorithm is difficult to solve and is computationally expensive. Once a miner solves this, they get a right
  to submit the valid block to the blockchain containing the transactions. The solution to the proof of work is verified by
  the other miners once the other miner has submitted the solution. With this agreed upon verification, the miner can include
  the block of transactions into the blockchain. As a reward to the miner he gets the cryptocurrencies and also gives the
  control as to the rate at which the new blocks are coming into the blockchain. The capability of miners to add the blocks
  can be slowed down by increasing the difficulty of the proof of work algorithm or it can be made fast by decreasing the
  difficulty of the same.

- Blocks -
     - blocks consist of 4 fundamental pieces of data.
          1) Timestamp - in milliseconds to record when the block was created.
          2) lastHash - the hash of the block that came before it.
          3) Hash - the hash generated of its own data.
          4) data - the data that is to be stored in the block.

          follow the git repo for code explanation

- In a blockchain the hash value is calculated based on the current data and the previous hash value, but what about the initial
  block, where does it get the previous hash value from? In order to eliminate such things there is a concept called genesis block
  The genesis block servers the purpose of being the origin of the blockchain. It is a dummy block with all the dummy values like
  the timestamp, lastHash, data etc. When someone adds the first block to the blockchain, it sets its lastHash as the hash of the
  genesis block.
  Implementation in the git repo.

- Generating has values. Hash value is generated from timestamp, lastHash, and stored data. For hashing we use the algorithm called
  SHA-256, s - secure, h - hash, a - algorithm, 256 is the fixed size of 256 bits or 32 chars for the hash. It is a one way has algorithm,
  meaning we can generate the hash from the data but we cannot decrypt the hashed value back to the original data. It is useful for the block
  validation.
  Implementation in the git repo.

- Making a test environment is better than running nodemon everytime. For this we use 'jest' as the package. This framework with look for the
  '*.test.js' files.

- Blockchain - It is a chain of blocks or an array of blocks where the initial block is the genesis block and the new blocks are added
  to the chain and are linked together.

- Multiple Chain Validators - with multiple contributors adding to the blockchain miners will each have their own version of the chain. If the
  miner wants to add a new block to the chain, then he has to add it to the other blockchains also so that it can be accepted and each has an
  updated version of the blockchain. In order for the other miners to accept it, there has to be some kind of validation. The principle form of validation
  is to accept longer chains that come in. Suppose now all the miners have same blockchain length and now one miner adds one block and another miner adds
  two blocks then all the miners in the blockchain have to add two blocks to their chain because of the longest chain principle. This also resolves
  the problem of forking. Suppose we have 4 miners of same initial blockchain length. Suppose half of the miners have added the block of the first
  miner and the rest half added the block of the second miner. The problem is all the blockchains have same length so now which one to pick. If the
  other miner appends a few more blockchains to the blockchain to either the first miner or the second miner then the entire blockchain will
  follow the one with the longer chain. In this way the problem of forking is eliminated.
  Implementation in github repo

- Peer-to-peer servers
  This server connects multiple users running this blockchain application. Everyone running the blockchain application will be considered a peer.
  The first peer to open and start the application starts the peer to peer server. We use something called as web sockets for this peer to peer server
  which allows us to connect to multiple servers running node.js application. It will open up a port where it will listen to web socket connection. When the
  other start up the application they will fire up the nodejs applications they will start their own web socket servers too, but they now connect to the original
  server through the open port. In that way the original server detects that new connections have been attempting to connect and thus makes a connection
  with those instances. Through this connection all the peers have the ability to broadcast data to all the other connected peers. As each new per connects to
  blockchain application we have to make sure that all the peers have the updated blockchain. If one peer adds a new block then we will have the ability to
  coomunicate it to all the other connected peers over the web socket. There are two possibilities how an initial server would behave.
  1) As the inital instance of the blockchain the node will first start the initial peer to peer server and will wait for connections as the peers applications
    start up.
  2) The later instances of the blockchain application will connect to the original server in the step 1 and connect over a designated web socket port.
  Implementation in github.

- Proof of work
  It is a system that requires miners to do computational work to add blocks. It has an advantage to prevent the dishonest peers from replacing the entire
  blockchain by the corrupt data. By introducing the proof of work it makes it computationally rediculus to generate the corrupted data. Proof of Work System
  makes it manageable to submit one block but it is unproductive when it comes to generate an entire chain. Many cryptocurrencies like bitcoin utilize the
  proof of work concept inspired by hashcash which was used to prevent the email spamming and also DoS attacks which were overloading the web servers
  The prof of work system inspired by hashcash works as the following way,
  - At any given point there is a level of difficulty in the blockchain system, depending on this difficulty when miners try to add a new block, we have to find
    a hash value that matches this difficulty. For this matching, miners have to find the same number of leading zeros as the current difficulty for the generated
    hash of the new block to add to the chain. Finding the certain number of leading zeros becomes exponentially harder as the difficulty rises. On order to solve
    the proof of work, the miners have to solve a large number of hashes to find the one with the current difficulty. The miner generates the new hash by the current
    data as well as an adjusting value called 'nonce' so that with the help of this nonce everytime a new hash would be generated. A nonce is the term in the
    cryptography which means that it can only be used once. A nonce value starts from 0 and keeps on increasing and this nonce value is then stored as the part of the
    block. This takes a lot of computation work and this is the reason why adding a block to the blockchain is called mining. Once the miner has submitted the block then
    he would send the final nonce value to the other miners. As the other miners know the nonce value they can immediately validate the identity of the new block and then
    add it to their chain.
  - Because of this difficulty setting blockchains have the ability to control the rate at which the new blocks are added to the system. The higher the difficulty, the
    longer the time taken by the miner to add the block. Bitcoin has a goal of adding the block to the blockchain for every 10 min.

  - 51% attack
    - This is the senario where the dishonest miner has at least 51% of the entire blockchain networks computing power and hence they can replace the current blockchain with
    the one in their favor.

  - Implementing Dynamic block difficulty
    Each block has a difficulty variable and we also set the mine rate that is the rate at which each block is mined. The difficulty adjustment mechanism works as follows,
    We will compute the difference in the timestamps of the current block and the previous block in the blockchain and if the difference in the timestamps is smaller than
    the mine rate then increment the difficulty by 1. If the difference is bigger than the mine rate then decrement the difficulty.

- Wallets, keys and transactions
  - A wallet is a core object of the cryptocurrency with three main components, first is the balance of the individual, second is to store the individual's private and public
    keys - private key is used to sign the transfer of cryptocurrency that the individual makes and the public key is used to verify that signature, the third is the public address - with
    this address other can send the cryptocurrency to the individual. The concept of exchanging currency is represented through the objects called transactions. These transactions consist
    of two primary components, the input provides the details of the sender which includes the timestamp, sender's balance, digital signature and public key, second the transaction consist
    of output objects which contain the amount and the address which represents the amt the sender wants to send to that address. Interestingly the sender also creates an output for him/herself
    as it specifies the amt the sender will have after the transaction. The blocks in the chain will contain one or more of these transaction objects
    Implementation in github.




Transaction Pool
-	Its an object in the cryptocurrency network which contains all new transactions submitted by the individuals. As the individual do the cryptocurrency transactions, every new transaction would be stored in this object and these new transactions would be unconfirmed. They are unconfirmed because they are not officially included in the blockchain yet. So the miners do the job of creating the blocks that confirm the transactions. They take the group of these unconfirmed transactions and include them as a group of data for the new block in the blockchain. The blockchain conformations rate is same as the rate at which miners are set to mine new blocks. While the transactions objects can be created instantly there is a brief period when they are unconfirmed while the miner includes the transactions into the blockchain.

Miners in the Blockchain
-	Miners take the transaction from the pool and store them into blocks
-	Miners receive rewards for mining
-	Transactions go from “unconfirmed” in the pool to “confirmed” in the chain.

Nuance of Wallet Balance
-	Balance = all output amount that belong to a user
-	Update the balance at least before each transaction.
-	The balance of a particular user is the sum total of all outputs of the user’s transactions since the most recent transactions because it is quite possible that there may be a double count of transactions within the user’s blockchain history.


It is a cryptocurrency similar to blockchain in action. This blockchain has been developed using nodejs and expressjs. It includes various features like generating hashes, real time peer-to-peer transactions, implementation of proof of work algorithm, signing the transactions with digital signatures, a transaction pool which contains the real time list of incoming data etc. Also I have built an API surrounding this blockchain for easy usage.
